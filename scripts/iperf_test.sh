#!/bin/bash

function display_help
{
  echo "--rules"
  echo "   Number of rules: 10, 100, 1000, 10000"
  echo "--rules-proto"
  echo "   Rules protocol(s): all, udp-only, tcp-only"
  echo "--rules-type"
  echo "   Rules type: all, tcp-opt-only, no-tcp-opt"
  echo "--matches"
  echo "   Number of matches per rule: <number> or <min:max> (random range)"
  echo "--targets"
  echo "   Number of targets per rule: <number> or <min:max> (random range)"
  echo "--iperf-flow-size"
  echo "   Flow size in bytes generated by iperf (> 0)"
  echo "--iperf-proto"
  echo "   Type of traffic generated by iperf: udp, tcp"
  echo "--background-udp"
  echo "   Flow size in bytes for a background udp traffic"
  echo "--background-tcp"
  echo "   Flow size in bytes for a background tcp traffic"
}

function is_number
{
  case $1 in
    ''|*[!0-9]*)
      echo false;;

    *)
      echo true;;
  esac
}

PROTOCOL_ALL=0
PROTOCOL_UDP=1
PROTOCOL_TCP=2
TYPE_ALL=3
TYPE_TCP_OPTS_ONLY=4
TYPE_NO_TCP_OPTS=5

rules_nb=""
rules_proto=""
rules_type=""
matches_random=""
matches_nb=""
matches_min=""
matches_max=""
targets_random=""
targets_nb=""
targets_min=""
targets_max=""
iperf_flow=""
iperf_proto=""
back_udp=""
back_tcp=""

parsed=0
mask_rules=$((1<<0))
mask_rules_proto=$((1<<1))
mask_rules_type=$((1<<2))
mask_matches=$((1<<3))
mask_targets=$((1<<4))
mask_iperf_flow=$((1<<5))
mask_iperf_proto=$((1<<6))
mask_back_udp=$((1<<7))
mask_back_tcp=$((1<<8))

nb_args=0
while [[ $# -gt 0 ]]; do
  key="$1"

  case $key in

    --help)
      echo "Syntax $0"
      display_help
      exit 1;;

    --rules)
      if [[ $(( parsed & $mask_rules )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif [ "$2" != 10 ] && [ "$2" != 100 ] && [ "$2" != 1000 ] && [ "$2" != 10000 ]; then
        echo "$key value error"
        exit 1
      fi
      rules_nb=$2
      let parsed+=$mask_rules;;

    --rules-proto)
      if [[ $(( parsed & $mask_rules_proto )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif [ "$2" == "all" ]; then
        rules_proto=${PROTOCOL_ALL}
      elif [ "$2" == "udp-only" ]; then
        rules_proto=${PROTOCOL_UDP}
      elif [ "$2" == "tcp-only" ]; then
        rules_proto=${PROTOCOL_TCP}
      else
        echo "$key value error"
        exit 1
      fi
      let parsed+=$mask_rules_proto;;

    --rules-type)
      if [[ $(( parsed & $mask_rules_type )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif [ "$2" == "all" ]; then
        rules_type=${TYPE_ALL}
      elif [ "$2" == "tcp-opt-only" ]; then
        rules_type=${TYPE_TCP_OPTS_ONLY}
      elif [ "$2" == "no-tcp-opt" ]; then
        rules_type=${TYPE_NO_TCP_OPTS}
      else
        echo "$key value error"
        exit 1
      fi
      let parsed+=$mask_rules_type;;

    --matches)
      if [[ $(( parsed & $mask_matches )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif [[ "$2" == *":"* ]]; then
        matches_random=1
        matches_min=${2%:*}
        matches_max=${2#*:}
        if ! $(is_number $matches_min); then
          echo "$key min is not a number"
          exit 1
        elif [[ $matches_min -eq 0 ]]; then
          echo "$key min must be greater than 0"
          exit 1
        elif ! $(is_number $matches_max); then
          echo "$key max is not a number"
          exit 1
        elif [[ $matches_min -gt $matches_max ]]; then
          echo "$key min can't be greater than max"
          exit 1
        fi
      elif $(is_number $2); then
        if [[ $2 -eq 0 ]]; then
          echo "$key value must be greater than 0"
          exit 1
        fi
        matches_random=0
        matches_nb=$2
      else
        echo "$key value error"
        exit 1
      fi
      let parsed+=$mask_matches;;

    --targets)
      if [[ $(( parsed & $mask_targets )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif [[ "$2" == *":"* ]]; then
        targets_random=1
        targets_min=${2%:*}
        targets_max=${2#*:}
        if ! $(is_number $targets_min); then
          echo "$key min is not a number"
          exit 1
        elif [[ $targets_min -eq 0 ]]; then
          echo "$key min must be greater than 0"
          exit 1
        elif ! $(is_number $targets_max); then
          echo "$key max is not a number"
          exit 1
        elif [[ $targets_min -gt $targets_max ]]; then
          echo "$key min can't be greater than max"
          exit 1
        fi
      elif $(is_number $2); then
        if [[ $2 -eq 0 ]]; then
          echo "$key value must be greater than 0"
          exit 1
        fi
        targets_random=0
        targets_nb=$2
      else
        echo "$key value error"
        exit 1
      fi
      let parsed+=$mask_targets;;

    --iperf-flow-size)
      if [[ $(( parsed & $mask_iperf_flow )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif $(is_number $2); then
        iperf_flow=$2
      else
        echo "$key value error"
        exit 1
      fi
      let parsed+=$mask_iperf_flow;;

    --iperf-proto)
      if [[ $(( parsed & $mask_iperf_proto )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif [ "$2" == "udp" ]; then
        iperf_proto=${PROTOCOL_UDP}
      elif [ "$2" == "tcp" ]; then
        iperf_proto=${PROTOCOL_TCP}
      else
        echo "$key value error"
        exit 1
      fi
      let parsed+=$mask_iperf_proto;;

    --background-udp)
      if [[ $(( parsed & $mask_back_udp )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif $(is_number $2); then
        back_udp=$2
      else
        echo "$key value error"
        exit 1
      fi
      let parsed+=$mask_back_udp;;

    --background-tcp)
      if [[ $(( parsed & $mask_back_tcp )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif $(is_number $2); then
        back_tcp=$2
      else
        echo "$key value error"
        exit 1
      fi
      let parsed+=$mask_back_tcp;;

    *)
      echo "Unknown parameter $key"
      exit 1;;

  esac

  let nb_args+=1
  shift
  shift
done

if [[ ${nb_args} -ne 9 ]]; then
  echo "Wrong number of arguments (see $0 --help)"
  exit 1
fi

# ==========================================

echo
echo "Number of rules: $rules_nb"

if [[ $rules_proto -eq ${PROTOCOL_ALL} ]]; then
  echo "Rules protocols: UDP & TCP"
else
  [[ $rules_proto -eq ${PROTOCOL_UDP} ]] && rules_proto_str="UDP" || rules_proto_str="TCP"
  echo "Rules protocol: $rules_proto_str"
fi

if [[ $rules_type -eq ${TYPE_ALL} ]]; then
  echo "Rules type: With and without TCP options"
else
  [[ $rules_type -eq ${TYPE_TCP_OPTS_ONLY} ]] && rules_type_str="With TCP options only" || rules_type_str="Without TCP options"
  echo "Rules type: $rules_type_str"
fi

if [[ $matches_random -eq 0 ]]; then
  echo "Fixed number of matches: $matches_nb"
else
  echo "Random number of matches: [$matches_min:$matches_max]"
fi

if [[ $targets_random -eq 0 ]]; then
  echo "Fixed number of targets: $targets_nb"
else
  echo "Random number of targets: [$targets_min:$targets_max]"
fi

echo "Iperf flow size (bytes): $iperf_flow"

[[ $iperf_proto -eq ${PROTOCOL_UDP} ]] && iperf_proto_str="UDP" || iperf_proto_str="TCP"
echo "Iperf flow protocol: $iperf_proto_str"

echo "Background UDP flow size (bytes): $back_udp"
echo "Background TCP flow size (bytes): $back_tcp"
echo

# ==========================================

#TODO $RANDOM range is 0-32767 (modulo higher is useless) -> find a way when we need more

function get_random_match
{
  local _proto=$1
  local _type=$2

  # branch 1: ip field
  # branch 2: udp field
  # branch 3: tcp field
  # branch 4: tcp options
  local _branch=0

  if [[ _proto -eq PROTOCOL_UDP ]]; then
    let _branch=$(( RANDOM % 2 + 1 ))
  elif [[ _proto -eq PROTOCOL_TCP ]]; then
    if [[ _type -eq TYPE_TCP_OPTS_ONLY ]]; then
      let _branch=4
    elif [[ _type -eq TYPE_NO_TCP_OPTS ]]; then
      if [[ $(( RANDOM % 2 )) -eq 0 ]]; then
        let _branch=3
      else
        let _branch=1
      fi
    else
      if [[ $(( RANDOM % 2 )) -eq 0 ]]; then
        let _branch=$(( RANDOM % 2 + 3 ))
      else
        let _branch=1
      fi
    fi
  fi

  if [[ _branch -eq 1 ]]; then
    case $(( RANDOM % 13 )) in
      0)
        echo "ip-ver $(( RANDOM % 16 ))";;
      1)
        echo "ip-ihl $(( RANDOM % 16 ))";;
      2)
        echo "ip-dscp $(( RANDOM % 64 ))";;
      3)
        echo "ip-ecn $(( RANDOM % 4 ))";;
      4)
        echo "ip-len $(( RANDOM % 65536 ))";;
      5)
        echo "ip-id $(( RANDOM % 65536 ))";;
      6)
        echo "ip-flags $(( RANDOM % 8 ))";;
      7)
        echo "ip-frag-offset $(( RANDOM % 8192 ))";;
      8)
        echo "ip-ttl $(( RANDOM % 256 ))";;
      9)
        [[ $(( RANDOM % 2 )) -eq 0 ]] && local _proto="udp" || local _proto="tcp"
        echo "ip-proto $_proto";;
      10)
        echo "ip-checksum $(( RANDOM % 65536 ))";;
      11)
        local a=$(( RANDOM % 256 ))
        local b=$(( RANDOM % 256 ))
        local c=$(( RANDOM % 256 ))
        local d=$(( RANDOM % 256 ))
        echo "ip-saddr $a.$b.$c.$d";;
      12)
        local a=$(( RANDOM % 256 ))
        local b=$(( RANDOM % 256 ))
        local c=$(( RANDOM % 256 ))
        local d=$(( RANDOM % 256 ))
        echo "ip-daddr $a.$b.$c.$d";;
    esac
  elif [[ _branch -eq 2 ]]; then
    case $(( RANDOM % 4 )) in
      0)
        echo "udp-sport $(( RANDOM % 65536 ))";;
      1)
        echo "udp-dport $(( RANDOM % 65536 ))";;
      2)
        echo "udp-len $(( RANDOM % 65536 ))";;
      3)
        echo "udp-checksum $(( RANDOM % 65536 ))";;
    esac
  elif [[ _branch -eq 3 ]]; then
    case $(( RANDOM % 10 )) in
      0)
        echo "tcp-sport $(( RANDOM % 65536 ))";;
      1)
        echo "tcp-dport $(( RANDOM % 65536 ))";;
      2)
        echo "tcp-seq-num $(( RANDOM % 4294967296 ))";;
      3)
        echo "tcp-ack-num $(( RANDOM % 4294967296 ))";;
      4)
        echo "tcp-offset $(( RANDOM % 16 ))";;
      5)
        echo "tcp-reserved $(( RANDOM % 16 ))";;
      6)
        echo "tcp-flags $(( RANDOM % 256 ))";;
      7)
        echo "tcp-win $(( RANDOM % 65536 ))";;
      8)
        echo "tcp-checksum $(( RANDOM % 65536 ))";;
      9)
        echo "tcp-urg-ptr $(( RANDOM % 65536 ))";;
    esac
  else
    case $(( RANDOM % 3 )) in
      0)
        echo "tcp-opt-mss $(( RANDOM % 65536 ))";;
      1)
        echo "tcp-opt-wscale $(( RANDOM % 256 ))";;
      2)
        echo "tcp-opt-timestamp $(( RANDOM % 9223372036854775808 ))";;
      #TODO construct "real" sack, fast-open, mptcp ???
    esac
  fi
}

function get_random_target
{
  local _proto=$1
  local _type=$2

  # branch 1: ip/udp/tcp field -> only ip "ttl" to avoid issues
  # branch 2: tcp options
  local _branch=0

  if [[ _proto -eq PROTOCOL_UDP ]] || [[ _type -eq TYPE_NO_TCP_OPTS ]]; then
    let _branch=1
  elif [[ _type -eq TYPE_TCP_OPTS_ONLY ]]; then
    let _branch=2
  else
    let _branch=$(( RANDOM % 2 + 1 ))
  fi

  if [[ _branch -eq 1 ]]; then
    echo "mod ip-ttl $(( RANDOM % 256 ))"
  else
    case $(( RANDOM % 3 )) in
      0)
        echo "mod tcp-opt-mss $(( RANDOM % 65536 ))";;
      1)
        echo "mod tcp-opt-wscale $(( RANDOM % 256 ))";;
      2)
        echo "mod tcp-opt-timestamp $(( RANDOM % 9223372036854775808 ))";;
      #TODO "add" options
    esac
  fi
}

function rule_gen
{
  touch /home/vagrant/random_rules

  local i=0
  until [ $i -eq $rules_nb ]; do
    echo -n "mmb add" >> /home/vagrant/random_rules

    if [[ $_proto -eq ${PROTOCOL_ALL} ]] && [[ $rules_type -ne ${TYPE_TCP_OPTS_ONLY} ]]; then
      if [[ $(( RANDOM % 2 )) -eq 0 ]]; then
        local _proto=${PROTOCOL_UDP}
      else
        local _proto=${PROTOCOL_TCP}
      fi
    else
      local _proto=$rules_proto
    fi

    local max_nb_matches=0
    if [[ $matches_random -eq 0 ]]; then
      max_nb_matches=$matches_nb
    else
      max_nb_matches=$(( RANDOM % ($(( $matches_max - $matches_min + 1 ))) + $matches_min ))
    fi

    local j=0
    until [ $j -eq $max_nb_matches ]; do
      echo -n " $(get_random_match $_proto $rules_type)" >> /home/vagrant/random_rules
      let j+=1
    done

    local max_nb_targets=0
    if [[ $targets_random -eq 0 ]]; then
      max_nb_targets=$targets_nb
    else
      max_nb_targets=$(( RANDOM % ($(( $targets_max - $targets_min + 1 ))) + $targets_min ))
    fi

    local j=0
    until [ $j -eq $max_nb_targets ]; do
      echo -n " $(get_random_target $_proto $rules_type)" >> /home/vagrant/random_rules
      let j+=1
    done

    echo "" >> /home/vagrant/random_rules
    let i+=1
  done

  sudo vppctl -s /run/vpp/cli-vpp.sock exec /home/vagrant/random_rules
  rm /home/vagrant/random_rules
}

echo
echo "Topology initialization & configuration..."

{
  # enable kernel forwarding
  sudo sysctl -w net.ipv4.ip_forward=1
  sysctl -p

  # create vpp instance
  sudo vpp unix { log /tmp/vpp.log cli-listen /run/vpp/cli-vpp.sock } api-segment { prefix vpp } plugins { plugin dpdk_plugin.so { disable } }
  sleep 1

  # ns0 namespace
  sudo ip netns add ns0
  sudo ip link add vpp0 type veth peer name vethns0
  sudo ip link set vethns0 netns ns0
  sudo ip netns exec ns0 ip link set lo up
  sudo ip netns exec ns0 ip link set vethns0 up
  sudo ip netns exec ns0 ip addr add 10.0.0.1/24 dev vethns0
  sudo ip netns exec ns0 ethtool -K vethns0 rx off tx off
  sudo ethtool --offload vpp0 rx off tx off
  sudo ip link set vpp0 up

  # switching
  sudo vppctl -s /run/vpp/cli-vpp.sock create host-interface name vpp0
  sudo vppctl -s /run/vpp/cli-vpp.sock set interface state host-vpp0 up
  sudo vppctl -s /run/vpp/cli-vpp.sock set interface l2 bridge host-vpp0 1
  sudo vppctl -s /run/vpp/cli-vpp.sock create loopback interface
  sudo vppctl -s /run/vpp/cli-vpp.sock set interface l2 bridge loop0 1 bvi
  sudo vppctl -s /run/vpp/cli-vpp.sock set interface state loop0 up
  sudo vppctl -s /run/vpp/cli-vpp.sock set interface ip address loop0 10.0.0.10/24

  # ns2 namespace
  sudo vppctl -s /run/vpp/cli-vpp.sock tap connect tap0
  sudo ip netns add ns2
  sudo ip link set tap0 netns ns2
  sudo ip netns exec ns2 ip link set lo up
  sudo ip netns exec ns2 ip link set tap0 up
  sudo ip netns exec ns2 ip addr add 10.0.1.1/24 dev tap0

  # routing
  sudo vppctl -s /run/vpp/cli-vpp.sock set interface state tap-0 up
  sudo vppctl -s /run/vpp/cli-vpp.sock set interface ip address tap-0 10.0.1.10/24
  sudo ip netns exec ns0 ip route add default via 10.0.0.10
  sudo ip netns exec ns2 ip route add default via 10.0.1.10

  # fill ARP cache
  sudo ip netns exec ns0 ping 10.0.1.1 -c 5
  sudo ip netns exec ns2 ping 10.0.0.1 -c 5

  # enable MMB
  sudo vppctl -s /run/vpp/cli-vpp.sock mmb enable host-vpp0
  sudo vppctl -s /run/vpp/cli-vpp.sock mmb enable tap-0

  # fill MMB rule table
  rule_gen

  # iperf server
  sudo ip netns exec ns2 iperf3 -s -D -B 10.0.1.1
  sleep 1
} &> /dev/null

# iperf client (test & results)
[[ $iperf_proto -eq ${PROTOCOL_UDP} ]] && iperf_proto_flag="-u" || iperf_proto_flag=""
sudo ip netns exec ns0 iperf3 -c 10.0.1.1 -4 $iperf_proto_flag -n $iperf_flow -V
#TODO background traffic (udp & tcp) in parallel
sleep 1
#TODO filter & display results in our own format ?

echo
echo "Cleaning everything up..."

{
  # cleanup
  sudo kill -9 $(ps -aef | grep -v grep | grep iperf3 | awk '{print $2}')
  sudo kill -9 $(ps -aef | grep -v grep | grep vpp | awk '{print $2}')
  sudo ip link del vpp0
  sudo ip netns del ns0
  sudo ip netns del ns2
} &> /dev/null

