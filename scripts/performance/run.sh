#!/bin/bash

function display_help
{
  echo "--rules"
  echo "   Number of rules: 10, 100, 1000, 10000"
  echo "--rules-proto"
  echo "   Rules protocol(s): all, udp-only, tcp-only"
  echo "--rules-type"
  echo "   Rules type: all, tcp-opt-only, no-tcp-opt"
  echo "--matches"
  echo "   Number of matches per rule: <number> or <min:max> (random range)"
  echo "--targets"
  echo "   Number of targets per rule: <number> or <min:max> (random range)"
  echo "--iperf-flow-size"
  echo "   Flow size in bytes generated by iperf (> 0)"
  echo "--iperf-proto"
  echo "   Type of traffic generated by iperf: udp, tcp"
  echo "--background-udp"
  echo "   Flow size in bytes for a background udp traffic"
  echo "--background-tcp"
  echo "   Flow size in bytes for a background tcp traffic"
}

function is_number
{
  case $1 in
    ''|*[!0-9]*)
      echo false;;

    *)
      echo true;;
  esac
}

PROTOCOL_ALL=0
PROTOCOL_UDP=1
PROTOCOL_TCP=2
TYPE_ALL=3
TYPE_TCP_OPTS_ONLY=4
TYPE_NO_TCP_OPTS=5

rules_nb=""
rules_proto=""
rules_type=""
matches_random=""
matches_nb=""
matches_min=""
matches_max=""
targets_random=""
targets_nb=""
targets_min=""
targets_max=""
iperf_flow=""
iperf_proto=""
back_udp=""
back_tcp=""

parsed=0
mask_rules=$((1<<0))
mask_rules_proto=$((1<<1))
mask_rules_type=$((1<<2))
mask_matches=$((1<<3))
mask_targets=$((1<<4))
mask_iperf_flow=$((1<<5))
mask_iperf_proto=$((1<<6))
mask_back_udp=$((1<<7))
mask_back_tcp=$((1<<8))

nb_args=0
while [[ $# -gt 0 ]]; do
  key="$1"

  case $key in

    --help)
      echo "Syntax $0"
      display_help
      exit 1;;

    --rules)
      if [[ $(( parsed & $mask_rules )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      fi
      rules_nb=$2
      let parsed+=$mask_rules;;

    --rules-proto)
      if [[ $(( parsed & $mask_rules_proto )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif [ "$2" == "all" ]; then
        rules_proto=${PROTOCOL_ALL}
      elif [ "$2" == "udp-only" ]; then
        rules_proto=${PROTOCOL_UDP}
      elif [ "$2" == "tcp-only" ]; then
        rules_proto=${PROTOCOL_TCP}
      else
        echo "$key value error"
        exit 1
      fi
      let parsed+=$mask_rules_proto;;

    --rules-type)
      if [[ $(( parsed & $mask_rules_type )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif [ "$2" == "all" ]; then
        rules_type=${TYPE_ALL}
      elif [ "$2" == "tcp-opt-only" ]; then
        rules_type=${TYPE_TCP_OPTS_ONLY}
      elif [ "$2" == "no-tcp-opt" ]; then
        rules_type=${TYPE_NO_TCP_OPTS}
      else
        echo "$key value error"
        exit 1
      fi
      let parsed+=$mask_rules_type;;

    --matches)
      if [[ $(( parsed & $mask_matches )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif [[ "$2" == *":"* ]]; then
        matches_random=1
        matches_min=${2%:*}
        matches_max=${2#*:}
        if ! $(is_number $matches_min); then
          echo "$key min is not a number"
          exit 1
        elif [[ $matches_min -eq 0 ]]; then
          echo "$key min must be greater than 0"
          exit 1
        elif ! $(is_number $matches_max); then
          echo "$key max is not a number"
          exit 1
        elif [[ $matches_min -gt $matches_max ]]; then
          echo "$key min can't be greater than max"
          exit 1
        fi
      elif $(is_number $2); then
        if [[ $2 -eq 0 ]]; then
          echo "$key value must be greater than 0"
          exit 1
        fi
        matches_random=0
        matches_nb=$2
      else
        echo "$key value error"
        exit 1
      fi
      let parsed+=$mask_matches;;

    --targets)
      if [[ $(( parsed & $mask_targets )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif [[ "$2" == *":"* ]]; then
        targets_random=1
        targets_min=${2%:*}
        targets_max=${2#*:}
        if ! $(is_number $targets_min); then
          echo "$key min is not a number"
          exit 1
        elif [[ $targets_min -eq 0 ]]; then
          echo "$key min must be greater than 0"
          exit 1
        elif ! $(is_number $targets_max); then
          echo "$key max is not a number"
          exit 1
        elif [[ $targets_min -gt $targets_max ]]; then
          echo "$key min can't be greater than max"
          exit 1
        fi
      elif $(is_number $2); then
        if [[ $2 -eq 0 ]]; then
          echo "$key value must be greater than 0"
          exit 1
        fi
        targets_random=0
        targets_nb=$2
      else
        echo "$key value error"
        exit 1
      fi
      let parsed+=$mask_targets;;

#    --iperf-flow-size)
#      if [[ $(( parsed & $mask_iperf_flow )) -gt 0 ]]; then
#        echo "$key cannot be used more than once"
#        exit 1
#      elif $(is_number $2); then
#        iperf_flow=$2
#      else
#        echo "$key value error"
#        exit 1
#      fi
#      let parsed+=$mask_iperf_flow;;

    --iperf-proto)
      if [[ $(( parsed & $mask_iperf_proto )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif [ "$2" == "udp" ]; then
        iperf_proto=${PROTOCOL_UDP}
      elif [ "$2" == "tcp" ]; then
        iperf_proto=${PROTOCOL_TCP}
      else
        echo "$key value error"
        exit 1
      fi
      [[ $iperf_proto -eq ${PROTOCOL_UDP} ]] && iperf_proto_flag="-u" || iperf_proto_flag=""
      let parsed+=$mask_iperf_proto;;

    --background-udp)
      if [[ $(( parsed & $mask_back_udp )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif $(is_number $2); then
        back_udp=$2
      else
        echo "$key value error"
        exit 1
      fi
      let parsed+=$mask_back_udp;;

    --background-tcp)
      if [[ $(( parsed & $mask_back_tcp )) -gt 0 ]]; then
        echo "$key cannot be used more than once"
        exit 1
      elif $(is_number $2); then
        back_tcp=$2
      else
        echo "$key value error"
        exit 1
      fi
      let parsed+=$mask_back_tcp;;

    *)
      echo "Unknown parameter $key"
      exit 1;;

  esac

  let nb_args+=1
  shift
  shift
done

#if [[ ${nb_args} -ne 9 ]]; then
#  echo "Wrong number of arguments (see $0 --help)"
#  exit 1
#fi

# ==========================================
: '
echo
echo "Number of rules: $rules_nb"

if [[ $rules_proto -eq ${PROTOCOL_ALL} ]]; then
  echo "Rules protocols: UDP & TCP"
else
  [[ $rules_proto -eq ${PROTOCOL_UDP} ]] && rules_proto_str="UDP" || rules_proto_str="TCP"
  echo "Rules protocol: $rules_proto_str"
fi

if [[ $rules_type -eq ${TYPE_ALL} ]]; then
  echo "Rules type: With and without TCP options"
else
  [[ $rules_type -eq ${TYPE_TCP_OPTS_ONLY} ]] && rules_type_str="With TCP options only" || rules_type_str="Without TCP options"
  echo "Rules type: $rules_type_str"
fi

if [[ $matches_random -eq 0 ]]; then
  echo "Fixed number of matches: $matches_nb"
else
  echo "Random number of matches: [$matches_min:$matches_max]"
fi

if [[ $targets_random -eq 0 ]]; then
  echo "Fixed number of targets: $targets_nb"
else
  echo "Random number of targets: [$targets_min:$targets_max]"
fi

echo "Iperf flow size (bytes): $iperf_flow"

[[ $iperf_proto -eq ${PROTOCOL_UDP} ]] && iperf_proto_str="UDP" || iperf_proto_str="TCP"
echo "Iperf flow protocol: $iperf_proto_str"

echo "Background UDP flow size (bytes): $back_udp"
echo "Background TCP flow size (bytes): $back_tcp"
echo
'
# ==========================================

#TODO $RANDOM range is 0-32767 (modulo higher is useless) -> find a way when we need more

function get_random_match
{
  local _proto=$1
  local _type=$2

  # branch 1: ip field
  # branch 2: udp field
  # branch 3: tcp field
  # branch 4: tcp options
  local _branch=0

  if [[ _proto -eq PROTOCOL_TCP ]]; then
    if [[ _type -eq TYPE_TCP_OPTS_ONLY ]]; then
      let _branch=5
    elif [[ _type -eq TYPE_NO_TCP_OPTS ]]; then
      let _branch=4
    else
      let _branch=3
    fi
  elif [[ _proto -eq PROTOCOL_UDP ]]; then
     let _branch=2
  fi

  if [[ _branch -eq 1 ]]; then
    case $(get_random 13) in
      0)
        echo "ip-ver $(get_random 16)";;
      1)
        echo "ip-ihl $(get_random 16)";;
      2)
        echo "ip-dscp $(get_random 64)";;
      3)
        echo "ip-ecn $(get_random 4)";;
      4)
        echo "ip-len $(get_random 65536)";;
      5)
        echo "ip-id $(get_random 65536)";;
      6)
        echo "ip-flags $(get_random 8)";;
      7)
        echo "ip-frag-offset $(get_random 8192)";;
      8)
        echo "ip-ttl $(get_random 256)";;
      9)
        echo "ip-checksum $(get_random 65536)";;
      10)
        local a=$(get_random 256)
        local b=$(get_random 256)
        local c=$(get_random 256)
        local d=$(get_random 256)
        echo "ip-saddr $a.$b.$c.$d";;
      11)
        local a=$(get_random 256)
        local b=$(get_random 256)
        local c=$(get_random 256)
        local d=$(get_random 256)
        echo "ip-daddr $a.$b.$c.$d";;
      12)
        echo "ip-payload $(get_random 65536)";;
    esac
  elif [[ _branch -eq 2 ]]; then
    case $(get_random 18) in
      0)
        echo "udp-sport $(get_random 65536)";;
      1)
        echo "udp-dport $(get_random 65536)";;
      2)
        echo "udp-len $(get_random 65536)";;
      3)
        echo "udp-checksum $(get_random 65536)";;
      4)
        echo "udp-payload $(get_random 65536)";;
      5)
        echo "ip-ver $(get_random 16)";;
      6)
        echo "ip-ihl $(get_random 16)";;
      7)
        echo "ip-dscp $(get_random 64)";;
      8)
        echo "ip-ecn $(get_random 4)";;
      9)
        echo "ip-len $(get_random 65536)";;
      10)
        echo "ip-id $(get_random 65536)";;
      11)
        echo "ip-flags $(get_random 8)";;
      12)
        echo "ip-frag-offset $(get_random 8192)";;
      13)
        echo "ip-ttl $(get_random 256)";;
      14)
        echo "ip-checksum $(get_random 65536)";;
      15)
        local a=$(get_random 256)
        local b=$(get_random 256)
        local c=$(get_random 256)
        local d=$(get_random 256)
        echo "ip-saddr $a.$b.$c.$d";;
      16)
        local a=$(get_random 256)
        local b=$(get_random 256)
        local c=$(get_random 256)
        local d=$(get_random 256)
        echo "ip-daddr $a.$b.$c.$d";;
      17)
        echo "ip-payload $(get_random 65536)";;
    esac
  elif [[ _branch -eq 3 ]]; then
    case $(get_random 32) in
      0)
        echo "tcp-sport $(get_random 65536)";;
      1)
        echo "tcp-dport $(get_random 65536)";;
      2)
        echo "tcp-seq-num $(get_random 4294967296)";;
      3)
        echo "tcp-ack-num $(get_random 4294967296)";;
      4)
        echo "tcp-offset $(get_random 16)";;
      5)
        echo "tcp-reserved $(get_random 16)";;
      6)
        echo "tcp-flags $(get_random 256)";;
      7)
        echo "tcp-win $(get_random 65536)";;
      8)
        echo "tcp-checksum $(get_random 65536)";;
      9)
        echo "tcp-urg-ptr $(get_random 65536)";;
      10)
        echo "tcp-payload $(get_random 65536)";;
      11)
        echo "tcp-opt-mss $(get_random 65536)";;
      12)
        echo "tcp-opt-wscale $(get_random 256)";;
      13)
        echo "tcp-opt-timestamp $(get_random 9223372036854775808)";;
      14)
        echo "tcp-opt-sackp";;
      15) # 1 block
        echo "tcp-opt-sack $(get_random 18446744073709551616)";;
      16) 
        echo "tcp-opt-fast-open $(get_random 65536)";;
      17)
        echo "tcp-opt-mptcp $(get_random 65536)";;      
      18) 
        echo "tcp-opt $(($(get_random 224) + 32)) $(get_random 65536)";;
      19)
        echo "ip-ver $(get_random 16)";;
      20)
        echo "ip-ihl $(get_random 16)";;
      21)
        echo "ip-dscp $(get_random 64)";;
      22)
        echo "ip-ecn $(get_random 4)";;
      23)
        echo "ip-len $(get_random 65536)";;
      24)
        echo "ip-id $(get_random 65536)";;
      25)
        echo "ip-flags $(get_random 8)";;
      26)
        echo "ip-frag-offset $(get_random 8192)";;
      27)
        echo "ip-ttl $(get_random 256)";;
      28)
        echo "ip-checksum $(get_random 65536)";;
      29)
        local a=$(get_random 256)
        local b=$(get_random 256)
        local c=$(get_random 256)
        local d=$(get_random 256)
        echo "ip-saddr $a.$b.$c.$d";;
      30)
        local a=$(get_random 256)
        local b=$(get_random 256)
        local c=$(get_random 256)
        local d=$(get_random 256)
        echo "ip-daddr $a.$b.$c.$d";;
      31)
        echo "ip-payload $(get_random 65536)";;  
    esac
  elif [[ _branch -eq 4 ]]; then
    case $(get_random 24) in
      0)
        echo "tcp-sport $(get_random 65536)";;
      1)
        echo "tcp-dport $(get_random 65536)";;
      2)
        echo "tcp-seq-num $(get_random 4294967296)";;
      3)
        echo "tcp-ack-num $(get_random 4294967296)";;
      4)
        echo "tcp-offset $(get_random 16)";;
      5)
        echo "tcp-reserved $(get_random 16)";;
      6)
        echo "tcp-flags $(get_random 256)";;
      7)
        echo "tcp-win $(get_random 65536)";;
      8)
        echo "tcp-checksum $(get_random 65536)";;
      9)
        echo "tcp-urg-ptr $(get_random 65536)";;
      10)
        echo "tcp-payload $(get_random 65536)";;
      11)
        echo "ip-ver $(get_random 16)";;
      12)
        echo "ip-ihl $(get_random 16)";;
      13)
        echo "ip-dscp $(get_random 64)";;
      14)
        echo "ip-ecn $(get_random 4)";;
      15)
        echo "ip-len $(get_random 65536)";;
      16)
        echo "ip-id $(get_random 65536)";;
      17)
        echo "ip-flags $(get_random 8)";;
      18)
        echo "ip-frag-offset $(get_random 8192)";;
      19)
        echo "ip-ttl $(get_random 256)";;
      20)
        echo "ip-checksum $(get_random 65536)";;
      21)
        local a=$(get_random 256)
        local b=$(get_random 256)
        local c=$(get_random 256)
        local d=$(get_random 256)
        echo "ip-saddr $a.$b.$c.$d";;
      22)
        local a=$(get_random 256)
        local b=$(get_random 256)
        local c=$(get_random 256)
        local d=$(get_random 256)
        echo "ip-daddr $a.$b.$c.$d";;
      23)
        echo "ip-payload $(get_random 65536)";;  
    esac
  else
    case $(get_random 8) in
      0)
        echo "tcp-opt-mss $(get_random 65536)";;
      1)
        echo "tcp-opt-wscale $(get_random 256)";;
      2)
        echo "tcp-opt-timestamp $(get_random 9223372036854775808)";;
      3)
        echo "tcp-opt-sackp";;
      4) # 1 block
        echo "tcp-opt-sack $(get_random 18446744073709551616)";;
      5) 
        echo "tcp-opt-fast-open $(get_random 65536)";;
      6)
        echo "tcp-opt-mptcp $(get_random 65536)";;      
      7) 
        echo "tcp-opt $(($(get_random 224) + 32)) $(get_random 65536)";;  
    esac
  fi
}

function get_random_target
{
  local _proto=$1
  local _type=$2
  local _branch=0

  if [[ _proto -eq PROTOCOL_UDP ]] || [[ _type -eq TYPE_NO_TCP_OPTS ]]; then
    let _branch=1
  elif [[ _type -eq TYPE_TCP_OPTS_ONLY ]]; then
    let _branch=2
  else
    let _branch=$(( $(get_random 2) + 1 ))
  fi

  if [[ _branch -eq 1 ]]; then
     case $(get_random 13) in
      0)
        echo "mod ip-ver $(get_random 16)";;
      1)
        echo "mod ip-ihl $(get_random 16)";;
      2)
        echo "mod ip-dscp $(get_random 64)";;
      3)
        echo "mod ip-ecn $(get_random 4)";;
      4)
        echo "mod ip-len $(get_random 65536)";;
      5)
        echo "mod ip-id $(get_random 65536)";;
      6)
        echo "mod ip-flags $(get_random 8)";;
      7)
        echo "mod ip-frag-offset $(get_random 8192)";;
      8)
        echo "mod ip-ttl $(get_random 256)";;
      9)
        echo "mod ip-checksum $(get_random 65536)";;
      10)
        local a=$(get_random 256)
        local b=$(get_random 256)
        local c=$(get_random 256)
        local d=$(get_random 256)
        echo "mod ip-saddr $a.$b.$c.$d";;
      11)
        local a=$(get_random 256)
        local b=$(get_random 256)
        local c=$(get_random 256)
        local d=$(get_random 256)
        echo "mod ip-daddr $a.$b.$c.$d";;
      12)
        echo "mod ip-payload $(get_random 65536)";;
    esac
  else
    case $(get_random 8) in
      0)
        echo "mod tcp-opt-mss $(get_random 65536)";;
      1)
        echo "mod tcp-opt-wscale $(get_random 256)";;
      2)
        echo "mod tcp-opt-timestamp $(get_random 9223372036854775808)";;
      3)
        echo "strip tcp-opt-sackp";;
      4) # 1 block
        echo "mod tcp-opt-sack $(get_random 18446744073709551616)";;
      5) 
        echo "mod tcp-opt-fast-open $(get_random 65536)";;
      6)
        echo "mod tcp-opt-mptcp $(get_random 65536)";;      
      7) 
        echo "mod tcp-opt $(($(get_random 224) + 32)) $(get_random 65536)";;  
      #TODO "add" options
    esac
  fi
}

function get_random {
   cmd="od -vAn -N8 -tu8 < /dev/urandom";
   r=$(eval $cmd);
   echo "$r % $1" | bc;
}

function rule_gen
{
  touch /home/vagrant/random_rules

  local i=0
  until [ $i -eq $rules_nb ]; do
    echo -n "mmb add" >> /home/vagrant/random_rules

    if [[ $_proto -eq ${PROTOCOL_ALL} ]] && [[ $rules_type -ne ${TYPE_TCP_OPTS_ONLY} ]]; then
      if [[ $(get_random 2) -eq 0 ]]; then
        local _rule_proto=${PROTOCOL_UDP}
      else
        local _rule_proto=${PROTOCOL_TCP}
      fi
    else
      local _rule_proto=$rules_proto
    fi

    local max_nb_matches=0
    if [[ $matches_random -eq 0 ]]; then
      max_nb_matches=$matches_nb
    else
      max_nb_matches=$(( $(get_random $(( $matches_max - $matches_min + 1 ))) + $matches_min ))
    fi
   
    local j=0
    until [ $j -eq $max_nb_matches ]; do
      echo -n " $(get_random_match $_rule_proto $rules_type)" >> /home/vagrant/random_rules
      let j+=1
    done

    local max_nb_targets=0
    if [[ $targets_random -eq 0 ]]; then
      max_nb_targets=$targets_nb
    else
      max_nb_targets=$(( $(get_random $(( $targets_max - $targets_min + 1 ))) + $targets_min ))
    fi

    local j=0
    until [ $j -eq $max_nb_targets ]; do
      echo -n " $(get_random_target $_rule_proto $rules_type)" >> /home/vagrant/random_rules
      let j+=1
    done

    echo "" >> /home/vagrant/random_rules
    let i+=1
  done

  sudo vppctl -s /run/vpp/cli-vpp.sock exec /home/vagrant/random_rules
  rm /home/vagrant/random_rules
}

# add rules to mmb
./flush.sh
rule_gen
#TODO background traffic (udp & tcp) in parallel
sleep 1
#TODO filter & display results in our own format ?

./performance/pings.sh

#iperf_output="$(./performance/iperf.sh $iperf_flow $iperf_proto_flag)"
for n in {1..100}; do 
   ./flush.sh
   rule_gen
   iperf_output="$(./performance/iperf.sh $iperf_proto_flag)";
   echo "$iperf_output" | grep sender; #| sed -e 's/.*\ sec\ \ //'
   echo "$iperf_output" | grep receiver; #| sed -e 's/.*\ sec\ \ //'
done


